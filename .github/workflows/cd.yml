name: CD

on:
  push:
    branches: [ "main" ]
    paths:
      - 'src/**'
      - 'k8s/**'
      - '.github/workflows/cd.yml'
  workflow_dispatch:

env:
  ECR_REPOSITORY: payments-service
  IMAGE_TAG: latest

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Login na AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      # 2. Login no ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # 3. Build e Push
      - name: Build and Push Docker Image
        id: build-push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          set -e
          
          if [ -z "$ECR_REGISTRY" ]; then
            echo "ERRO: ECR_REGISTRY n√£o est√° definido"
            exit 1
          fi
          
          FULL_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Building image: $FULL_IMAGE"
          
          docker build -t $FULL_IMAGE .
          
          echo "Pushing image to ECR..."
          docker push $FULL_IMAGE
          
          echo "FULL_IMAGE=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "Image $FULL_IMAGE pushed successfully"

      # 4. Substituir vari√°veis nos arquivos K8s
      - name: Prepare K8s manifests
        env:
          FULL_IMAGE: ${{ steps.build-push.outputs.FULL_IMAGE }}
          DB_VAL: ${{ secrets.PAYMENTS_DB_STRING }}
          KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          KEY_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          ACC_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -e
          
          echo "Validando vari√°veis obrigat√≥rias..."
          if [ -z "$FULL_IMAGE" ]; then
            echo "ERRO: FULL_IMAGE n√£o est√° definido"
            exit 1
          fi
          if [ -z "$DB_VAL" ]; then
            echo "ERRO: DB_VAL n√£o est√° definido"
            exit 1
          fi
          if [ -z "$KEY_ID" ] || [ -z "$KEY_SECRET" ] || [ -z "$KEY_TOKEN" ]; then
            echo "ERRO: Credenciais AWS n√£o est√£o definidas"
            exit 1
          fi
          if [ -z "$ACC_ID" ]; then
            echo "ERRO: ACC_ID n√£o est√° definido"
            exit 1
          fi
          
          mkdir -p k8s/payments/processed
          export FULL_IMAGE DB_VAL KEY_ID KEY_SECRET KEY_TOKEN ACC_ID
          
          echo "Processando arquivos YAML..."
          if command -v envsubst >/dev/null 2>&1; then
            envsubst < k8s/configmap.yaml > k8s/payments/processed/configmap.yaml
            envsubst < k8s/secret.yaml > k8s/payments/processed/secret.yaml
            envsubst < k8s/deployment.yaml > k8s/payments/processed/deployment.yaml
          else
            sed -e "s|\${FULL_IMAGE}|${FULL_IMAGE}|g" \
                -e "s|\${DB_VAL}|${DB_VAL}|g" \
                -e "s|\${KEY_ID}|${KEY_ID}|g" \
                -e "s|\${KEY_SECRET}|${KEY_SECRET}|g" \
                -e "s|\${KEY_TOKEN}|${KEY_TOKEN}|g" \
                -e "s|\${ACC_ID}|${ACC_ID}|g" \
                k8s/configmap.yaml > k8s/payments/processed/configmap.yaml
            sed -e "s|\${DB_VAL}|${DB_VAL}|g" \
                -e "s|\${KEY_ID}|${KEY_ID}|g" \
                -e "s|\${KEY_SECRET}|${KEY_SECRET}|g" \
                -e "s|\${KEY_TOKEN}|${KEY_TOKEN}|g" \
                k8s/secret.yaml > k8s/payments/processed/secret.yaml
            sed -e "s|\${FULL_IMAGE}|${FULL_IMAGE}|g" \
                k8s/deployment.yaml > k8s/payments/processed/deployment.yaml
          fi
          
          cp k8s/service.yaml k8s/payments/processed/service.yaml
          cp k8s/hpa.yaml k8s/payments/processed/hpa.yaml
          if [ -f k8s/ingress.yaml ]; then
            cp k8s/ingress.yaml k8s/payments/processed/ingress.yaml
          fi
          if [ -f k8s/middleware.yaml ]; then
            cp k8s/middleware.yaml k8s/payments/processed/middleware.yaml
          fi
          if [ -f k8s/namespace.yaml ]; then
            cp k8s/namespace.yaml k8s/payments/processed/namespace.yaml
          else
            echo "Aviso: namespace.yaml n√£o encontrado, ser√° criado automaticamente"
          fi
          
          if [ -f k8s/traefik/service.yaml ]; then
            cp k8s/traefik/service.yaml k8s/payments/processed/traefik-service.yaml
          fi
          
          if [ -f k8s/traefik/service-backup.yaml ]; then
            cp k8s/traefik/service-backup.yaml k8s/payments/processed/traefik-service-backup.yaml
          fi
          
          if grep -r '\${' k8s/payments/processed/*.yaml 2>/dev/null; then
            echo "ERRO: Vari√°veis n√£o substitu√≠das encontradas"
            exit 1
          fi

      # 5. Instalar kubectl
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      # 6. Configurar kubectl para EKS
      - name: Configure kubectl for EKS
        run: |
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region us-east-1

      # 6.5. Instalar Helm
      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version

      # 6.6. Instalar Traefik
      - name: Install Traefik
        run: |
          echo "Verificando se o Traefik j√° est√° instalado..."
          
          if kubectl get deployment traefik -n kube-system >/dev/null 2>&1 || \
             kubectl get daemonset traefik -n kube-system >/dev/null 2>&1 || \
             kubectl get deployment traefik -n traefik >/dev/null 2>&1; then
            echo "‚úÖ Traefik j√° est√° instalado no cluster."
            kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik 2>/dev/null || \
            kubectl get pods -n traefik -l app.kubernetes.io/name=traefik 2>/dev/null || true
          else
            echo "üì¶ Traefik n√£o encontrado. Instalando via Helm..."
            
            helm repo add traefik https://traefik.github.io/charts
            helm repo update
            
            echo "Instalando Traefik no namespace kube-system..."
            helm upgrade --install traefik traefik/traefik \
              --namespace kube-system \
              --create-namespace \
              --set service.type=ClusterIP \
              --set ports.web.port=80 \
              --set ports.websecure.port=443 \
              --wait \
              --timeout 5m || {
                echo "‚ö†Ô∏è  Erro ao instalar Traefik. Verificando status..."
                kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik || true
                exit 1
              }
            
            echo "‚úÖ Traefik instalado com sucesso!"
            echo "‚è≥ Aguardando pods ficarem prontos..."
            sleep 15
            
            echo "Status do Traefik:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik || true
          fi

      # 6.7. Verificar/Instalar CRDs do Traefik
      - name: Setup Traefik CRDs
        run: |
          echo "Verificando se o Traefik est√° instalado no cluster..."
          
          if kubectl get deployment traefik -n kube-system >/dev/null 2>&1 || \
             kubectl get daemonset traefik -n kube-system >/dev/null 2>&1 || \
             kubectl get deployment traefik -n traefik >/dev/null 2>&1; then
            echo "Traefik encontrado no cluster."
            
            if ! kubectl get crd middlewares.traefik.containo.us >/dev/null 2>&1; then
              echo "CRDs do Traefik n√£o encontrados. Tentando instalar..."
              
              kubectl apply -f https://raw.githubusercontent.com/traefik/traefik/v2.11/docs/content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml 2>/dev/null || \
              kubectl apply -f https://raw.githubusercontent.com/traefik/traefik/v3.0/docs/content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml 2>/dev/null || \
              echo "‚ö†Ô∏è  N√£o foi poss√≠vel instalar os CRDs automaticamente."
              
              echo "Aguardando CRDs ficarem dispon√≠veis..."
              sleep 10
            else
              echo "‚úÖ CRDs do Traefik j√° est√£o instalados."
            fi
          else
            echo "‚ö†Ô∏è  Traefik n√£o encontrado no cluster. O middleware ser√° ignorado."
            echo "Para usar o middleware, instale o Traefik primeiro ou use outro Ingress Controller."
          fi

      # 7. Deploy no EKS
      - name: Deploy to EKS
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          AWS_REGION: us-east-1
        run: |
          set -e
          
          if [ -f k8s/payments/processed/namespace.yaml ]; then
            kubectl apply -f k8s/payments/processed/namespace.yaml
          else
            kubectl create namespace payments --dry-run=client -o yaml | kubectl apply -f -
          fi
          
          if [ -z "$ECR_REGISTRY" ]; then
            ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          fi
          
          kubectl delete secret ecr-secret -n payments 2>/dev/null || true
          
          TOKEN=$(aws ecr get-login-password --region $AWS_REGION) || exit 1
          kubectl create secret docker-registry ecr-secret \
            --docker-server="$ECR_REGISTRY" \
            --docker-username=AWS \
            --docker-password="$TOKEN" \
            --namespace=payments || exit 1
          
          CURRENT_IMAGE=$(kubectl get deployment payments-deployment -n payments -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")
          NEW_IMAGE=$(grep "image:" k8s/payments/processed/deployment.yaml | awk '{print $2}' | tr -d '"')
          
          # # --- BLOCO DE LIMPEZA FOR√áADA ---
          # echo "üö® MODO DE CORRE√á√ÉO: For√ßando a exclus√£o do Load Balancer antigo (internet-facing)..."
          # kubectl delete svc payments-service -n payments --ignore-not-found=true
          
          # echo "‚è≥ Aguardando 35 segundos para a AWS remover o NLB antigo..."
          # sleep 35
          # # ------------------------------------------------
          
          kubectl apply -f k8s/payments/processed/configmap.yaml
          kubectl apply -f k8s/payments/processed/secret.yaml
          kubectl apply -f k8s/payments/processed/deployment.yaml
          
          kubectl apply -f k8s/payments/processed/service.yaml
          kubectl apply -f k8s/payments/processed/hpa.yaml
          
          if [ -f k8s/payments/processed/middleware.yaml ]; then
            if kubectl get crd middlewares.traefik.containo.us >/dev/null 2>&1; then
              echo "‚úÖ Aplicando middleware do Traefik..."
              kubectl apply -f k8s/payments/processed/middleware.yaml || {
                echo "‚ö†Ô∏è  Erro ao aplicar middleware. Continuando sem ele..."
              }
            else
              echo "‚ö†Ô∏è  CRDs do Traefik n√£o est√£o dispon√≠veis. Pulando aplica√ß√£o do middleware."
              echo "O Ingress funcionar√°, mas sem o stripPrefix. Configure o path corretamente no Ingress."
            fi
          fi
          
          if [ -f k8s/payments/processed/ingress.yaml ]; then
            echo "Aplicando Ingress..."
            kubectl apply -f k8s/payments/processed/ingress.yaml || {
              echo "‚ö†Ô∏è  Erro ao aplicar Ingress. Verifique se o Ingress Controller est√° instalado."
            }
          fi
          
          if [ -f k8s/payments/processed/traefik-service.yaml ]; then
            echo "üîÑ Deletando Traefik Service existente (se houver)..."
            kubectl delete svc traefik-loadbalancer -n kube-system --ignore-not-found=true
            
            echo "‚è≥ Aguardando 10 segundos para limpeza..."
            sleep 10
            
            echo "‚úÖ Aplicando Traefik Service com porta fixa (31551)..."
            kubectl apply -f k8s/payments/processed/traefik-service.yaml || {
              echo "‚ö†Ô∏è  Erro ao aplicar traefik-service.yaml. Tentando service-backup.yaml..."
              if [ -f k8s/payments/processed/traefik-service-backup.yaml ]; then
                kubectl apply -f k8s/payments/processed/traefik-service-backup.yaml
              fi
            }
          elif [ -f k8s/payments/processed/traefik-service-backup.yaml ]; then
            kubectl apply -f k8s/payments/processed/traefik-service-backup.yaml
          fi
          
          SKIP_ROLLOUT=false
          if [ -n "$CURRENT_IMAGE" ] && [ "$CURRENT_IMAGE" = "$NEW_IMAGE" ]; then
            READY=$(kubectl get deployment payments-deployment -n payments -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED=$(kubectl get deployment payments-deployment -n payments -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
            if [ "$READY" = "$DESIRED" ] && [ "$READY" != "0" ]; then
              echo "‚ÑπÔ∏è  Deployment j√° est√° pronto com a mesma imagem. Verificando se h√° mudan√ßas em outros recursos..."
              SKIP_ROLLOUT=true
            fi
          fi
          
          if [ "$SKIP_ROLLOUT" = "false" ]; then
            if [ -n "$CURRENT_IMAGE" ] && [ "$CURRENT_IMAGE" != "$NEW_IMAGE" ]; then
              echo "üîÑ Imagem mudou. Reiniciando deployment..."
              kubectl rollout restart deployment/payments-deployment -n payments
            else
              echo "üîÑ Aguardando deployment ficar pronto..."
            fi
          fi
          
          if ! kubectl rollout status deployment/payments-deployment -n payments --timeout=300s; then
            echo "ERRO: Rollout falhou ou timeout"
            echo ""
            echo "=== Status dos pods ==="
            kubectl get pods -n payments -o wide
            echo ""
            echo "=== Descri√ß√£o do deployment ==="
            kubectl describe deployment payments-deployment -n payments
            echo ""
            echo "=== Logs dos pods (√∫ltimos 50 linhas) ==="
            for pod in $(kubectl get pods -n payments -l app=payments -o jsonpath='{.items[*].metadata.name}'); do
              echo "--- Logs do pod: $pod ---"
              kubectl logs $pod -n payments --tail=50 || echo "N√£o foi poss√≠vel obter logs do pod $pod"
              echo ""
              echo "--- Descri√ß√£o do pod: $pod ---"
              kubectl describe pod $pod -n payments | tail -30
              echo ""
            done
            echo ""
            echo "=== Eventos do namespace ==="
            kubectl get events -n payments --sort-by='.lastTimestamp' | tail -20
            exit 1
          fi
          
          echo "Deploy conclu√≠do com sucesso!"

      # 8. Verificar Traefik e Load Balancer
      - name: Verify Traefik and Load Balancer
        run: |
          echo "üîç Verificando status do Traefik e Load Balancer..."
          sleep 10
          
          echo ""
          echo "=== 1. TRAEFIK EST√Å VIVO? ==="
          TRAEFIK_DEPLOYMENT=$(kubectl get deployment traefik -n kube-system 2>/dev/null || echo "")
          TRAEFIK_DAEMONSET=$(kubectl get daemonset traefik -n kube-system 2>/dev/null || echo "")
          
          if [ -n "$TRAEFIK_DEPLOYMENT" ]; then
            echo "‚úÖ Traefik Deployment encontrado:"
            kubectl get deployment traefik -n kube-system
            echo ""
            echo "Pods do Traefik:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik
            READY_PODS=$(kubectl get deployment traefik -n kube-system -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            DESIRED_PODS=$(kubectl get deployment traefik -n kube-system -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
            if [ "$READY_PODS" = "$DESIRED_PODS" ] && [ "$READY_PODS" != "0" ]; then
              echo "‚úÖ Traefik est√° RODANDO ($READY_PODS/$DESIRED_PODS pods prontos)"
            else
              echo "‚ö†Ô∏è  Traefik N√ÉO est√° totalmente pronto ($READY_PODS/$DESIRED_PODS pods)"
            fi
          elif [ -n "$TRAEFIK_DAEMONSET" ]; then
            echo "‚úÖ Traefik DaemonSet encontrado:"
            kubectl get daemonset traefik -n kube-system
            echo ""
            echo "Pods do Traefik:"
            kubectl get pods -n kube-system -l app.kubernetes.io/name=traefik
            READY_PODS=$(kubectl get daemonset traefik -n kube-system -o jsonpath='{.status.numberReady}' 2>/dev/null || echo "0")
            DESIRED_PODS=$(kubectl get daemonset traefik -n kube-system -o jsonpath='{.status.desiredNumberScheduled}' 2>/dev/null || echo "0")
            if [ "$READY_PODS" = "$DESIRED_PODS" ] && [ "$READY_PODS" != "0" ]; then
              echo "‚úÖ Traefik est√° RODANDO ($READY_PODS/$DESIRED_PODS pods prontos)"
            else
              echo "‚ö†Ô∏è  Traefik N√ÉO est√° totalmente pronto ($READY_PODS/$DESIRED_PODS pods)"
            fi
          else
            echo "‚ùå Traefik N√ÉO encontrado no cluster!"
            echo "Verifique se o Traefik est√° instalado:"
            echo "  kubectl get all -n kube-system | grep traefik"
            exit 1
          fi
          
          echo ""
          echo "=== 2. PORTA √â 31551? ==="
          TRAEFIK_SVC=$(kubectl get svc traefik-loadbalancer -n kube-system 2>/dev/null || echo "")
          if [ -z "$TRAEFIK_SVC" ]; then
            echo "‚ùå Service traefik-loadbalancer N√ÉO encontrado!"
            exit 1
          fi
          
          echo "Service traefik-loadbalancer:"
          kubectl get svc traefik-loadbalancer -n kube-system
          echo ""
          
          NODE_PORT=$(kubectl get svc traefik-loadbalancer -n kube-system -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}' 2>/dev/null || echo "")
          if [ -z "$NODE_PORT" ]; then
            NODE_PORT=$(kubectl get svc traefik-loadbalancer -n kube-system -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          fi
          
          if [ -z "$NODE_PORT" ]; then
            echo "‚ö†Ô∏è  NodePort n√£o encontrado no service. Verificando detalhes..."
            kubectl describe svc traefik-loadbalancer -n kube-system | grep -A 10 "Port:"
            NODE_PORT="N/A"
          else
            if [ "$NODE_PORT" = "31551" ]; then
              echo "‚úÖ PORTA CORRETA: $NODE_PORT (esperado: 31551)"
            else
              echo "‚ùå PORTA INCORRETA: $NODE_PORT (esperado: 31551)"
              echo ""
              echo "‚ö†Ô∏è  A porta n√£o √© 31551. O Target Group precisa ser atualizado para a porta $NODE_PORT"
              echo "Ou recrie o service com a porta correta."
            fi
          fi
          
          echo ""
          echo "=== 3. DNS DO NLB ==="
          NLB_HOSTNAME=$(kubectl get svc traefik-loadbalancer -n kube-system -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          if [ -n "$NLB_HOSTNAME" ]; then
            echo "‚úÖ Traefik NLB Hostname: $NLB_HOSTNAME"
            echo ""
            echo "Use este hostname para configurar o API Gateway"
            echo "As rotas devem ser configuradas com o prefixo /api/payments"
            if [ "$NODE_PORT" != "N/A" ]; then
              echo ""
              echo "‚ö†Ô∏è  IMPORTANTE: Configure o Target Group para usar a porta $NODE_PORT"
            fi
          else
            echo "‚è≥ NLB do Traefik ainda est√° sendo provisionado..."
            echo "Aguarde alguns minutos e verifique novamente com:"
            echo "  kubectl get svc traefik-loadbalancer -n kube-system"
          fi
          
          echo ""
          echo "=== 4. STATUS DO SERVICE PAYMENTS ==="
          kubectl get svc payments-service -n payments
          
          echo ""
          echo "=== 5. STATUS DO MIDDLEWARE ==="
          kubectl get middleware -n payments 2>/dev/null || echo "Middleware n√£o encontrado ou CRD n√£o instalado"