name: CD

on:
  push:
    branches: [ "main" ]
    paths:
      - 'src/**'
      - 'k8s/**'
      - '.github/workflows/cd.yml'
  workflow_dispatch:

env:
  ECR_REPOSITORY: payments-service
  IMAGE_TAG: latest

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Login na AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      # 2. Login no ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # 3. Build e Push
      - name: Build and Push Docker Image
        id: build-push
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          set -e
          
          if [ -z "$ECR_REGISTRY" ]; then
            echo "ERRO: ECR_REGISTRY não está definido"
            exit 1
          fi
          
          FULL_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Building image: $FULL_IMAGE"
          
          docker build -t $FULL_IMAGE .
          
          echo "Pushing image to ECR..."
          docker push $FULL_IMAGE
          
          echo "FULL_IMAGE=$FULL_IMAGE" >> $GITHUB_OUTPUT
          echo "Image $FULL_IMAGE pushed successfully"

      # 4. Substituir variáveis nos arquivos K8s
      - name: Prepare K8s manifests
        env:
          FULL_IMAGE: ${{ steps.build-push.outputs.FULL_IMAGE }}
          DB_VAL: ${{ secrets.PAYMENTS_DB_STRING }}
          KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          KEY_SECRET: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          KEY_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
          ACC_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          set -e
          
          echo "Validando variáveis obrigatórias..."
          if [ -z "$FULL_IMAGE" ]; then
            echo "ERRO: FULL_IMAGE não está definido"
            exit 1
          fi
          if [ -z "$DB_VAL" ]; then
            echo "ERRO: DB_VAL não está definido"
            exit 1
          fi
          if [ -z "$KEY_ID" ] || [ -z "$KEY_SECRET" ] || [ -z "$KEY_TOKEN" ]; then
            echo "ERRO: Credenciais AWS não estão definidas"
            exit 1
          fi
          if [ -z "$ACC_ID" ]; then
            echo "ERRO: ACC_ID não está definido"
            exit 1
          fi
          
          mkdir -p k8s/payments/processed
          export FULL_IMAGE DB_VAL KEY_ID KEY_SECRET KEY_TOKEN ACC_ID
          
          echo "Processando arquivos YAML..."
          if command -v envsubst >/dev/null 2>&1; then
            envsubst < k8s/configmap.yaml > k8s/payments/processed/configmap.yaml
            envsubst < k8s/secret.yaml > k8s/payments/processed/secret.yaml
            envsubst < k8s/deployment.yaml > k8s/payments/processed/deployment.yaml
          else
            sed -e "s|\${FULL_IMAGE}|${FULL_IMAGE}|g" \
                -e "s|\${DB_VAL}|${DB_VAL}|g" \
                -e "s|\${KEY_ID}|${KEY_ID}|g" \
                -e "s|\${KEY_SECRET}|${KEY_SECRET}|g" \
                -e "s|\${KEY_TOKEN}|${KEY_TOKEN}|g" \
                -e "s|\${ACC_ID}|${ACC_ID}|g" \
                k8s/configmap.yaml > k8s/payments/processed/configmap.yaml
            sed -e "s|\${DB_VAL}|${DB_VAL}|g" \
                -e "s|\${KEY_ID}|${KEY_ID}|g" \
                -e "s|\${KEY_SECRET}|${KEY_SECRET}|g" \
                -e "s|\${KEY_TOKEN}|${KEY_TOKEN}|g" \
                k8s/secret.yaml > k8s/payments/processed/secret.yaml
            sed -e "s|\${FULL_IMAGE}|${FULL_IMAGE}|g" \
                k8s/deployment.yaml > k8s/payments/processed/deployment.yaml
          fi
          
          cp k8s/service.yaml k8s/payments/processed/service.yaml
          cp k8s/hpa.yaml k8s/payments/processed/hpa.yaml
          if [ -f k8s/ingress.yaml ]; then
            cp k8s/ingress.yaml k8s/payments/processed/ingress.yaml
          fi
          if [ -f k8s/namespace.yaml ]; then
            cp k8s/namespace.yaml k8s/payments/processed/namespace.yaml
          else
            echo "Aviso: namespace.yaml não encontrado, será criado automaticamente"
          fi
          
          if grep -r '\${' k8s/payments/processed/*.yaml 2>/dev/null; then
            echo "ERRO: Variáveis não substituídas encontradas"
            exit 1
          fi

      # 5. Copiar arquivos K8s para EC2
      - name: Copy K8s files to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 90s
          source: "k8s/payments/processed/*.yaml"
          target: "/home/ubuntu/deploy/k8s/payments"
          strip_components: 3

      # 6. Deploy na EC2 via SSH
      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 600s
          script: |
            set -e
            
            ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
            AWS_ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
            AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            AWS_SESSION_TOKEN="${{ secrets.AWS_SESSION_TOKEN }}"
            AWS_DEFAULT_REGION="us-east-1"
            AWS_REGION="us-east-1"
            
            export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_DEFAULT_REGION AWS_REGION
            
            mkdir -p ~/.kube
            sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config 2>/dev/null || exit 1
            sudo chown ubuntu:ubuntu ~/.kube/config
            chmod 600 ~/.kube/config
            export KUBECONFIG=~/.kube/config
            
            kubectl create namespace payments --dry-run=client -o yaml | kubectl apply -f - 2>/dev/null || true
            
            if [ -z "$ECR_REGISTRY" ]; then
              ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
            fi
            
            kubectl delete secret ecr-secret -n payments 2>/dev/null || true
            
            if ! command -v aws &> /dev/null; then
              curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o awscliv2.zip
              unzip -q awscliv2.zip && sudo ./aws/install
              rm -rf awscliv2.zip aws
            fi
            
            TOKEN=$(aws ecr get-login-password --region $AWS_REGION) || exit 1
            kubectl create secret docker-registry ecr-secret \
              --docker-server="$ECR_REGISTRY" \
              --docker-username=AWS \
              --docker-password="$TOKEN" \
              --namespace=payments || exit 1
            
            kubectl apply -f /home/ubuntu/deploy/k8s/payments/configmap.yaml
            kubectl apply -f /home/ubuntu/deploy/k8s/payments/secret.yaml
            
            CURRENT_IMAGE=$(kubectl get deployment payments-deployment -n payments -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")
            NEW_IMAGE=$(grep "image:" /home/ubuntu/deploy/k8s/payments/deployment.yaml | awk '{print $2}' | tr -d '"')
            
            kubectl apply -f /home/ubuntu/deploy/k8s/payments/deployment.yaml
            kubectl apply -f /home/ubuntu/deploy/k8s/payments/service.yaml
            kubectl apply -f /home/ubuntu/deploy/k8s/payments/hpa.yaml
            if [ -f /home/ubuntu/deploy/k8s/payments/ingress.yaml ]; then
              kubectl apply -f /home/ubuntu/deploy/k8s/payments/ingress.yaml
            fi
            
            if [ -n "$CURRENT_IMAGE" ] && [ "$CURRENT_IMAGE" = "$NEW_IMAGE" ]; then
              READY=$(kubectl get deployment payments-deployment -n payments -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              if [ "$READY" != "0" ]; then
                echo "Deployment já está pronto, pulando rollout!"
                exit 0
              fi
            fi
            
            if [ -n "$CURRENT_IMAGE" ] && [ "$CURRENT_IMAGE" != "$NEW_IMAGE" ]; then
              kubectl rollout restart deployment/payments-deployment -n payments
            fi
            
            if ! kubectl rollout status deployment/payments-deployment -n payments --timeout=120s; then
              echo "ERRO: Rollout falhou ou timeout"
              echo ""
              echo "=== Status dos pods ==="
              kubectl get pods -n payments -o wide
              echo ""
              echo "=== Descrição do deployment ==="
              kubectl describe deployment payments-deployment -n payments
              echo ""
              echo "=== Logs dos pods (últimos 50 linhas) ==="
              for pod in $(kubectl get pods -n payments -l app=payments -o jsonpath='{.items[*].metadata.name}'); do
                echo "--- Logs do pod: $pod ---"
                kubectl logs $pod -n payments --tail=50 || echo "Não foi possível obter logs do pod $pod"
                echo ""
                echo "--- Descrição do pod: $pod ---"
                kubectl describe pod $pod -n payments | tail -30
                echo ""
              done
              echo ""
              echo "=== Eventos do namespace ==="
              kubectl get events -n payments --sort-by='.lastTimestamp' | tail -20
              exit 1
            fi
            
            echo "Deploy concluído com sucesso!"